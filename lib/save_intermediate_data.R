# Goal: 
# 1. Load in all data relevant to trehalose project. 
# 2. Subset all data to only the high quality samples. 
# 3. Subset all data to only the pertinent observations. 
# 4. Combine all tabular data into one tibble. 
# 5. Save the tibble as input for the analysis scripts. 
# 6. Save the tree as input for the analysis scripts. 

# Functions -------------------------------------------------------------------#
#' format_tree
#' A function to drop unwanted samples from the tree and convert PSM_ID into
#'   ERIN_ID. 
#'
#' @param tree Phylogenetic tree
#' @param sample_lookup A key with 2 columns: PSM_ID, used for UMich sequencing 
#' core, and ERIN_ID, study ID numbers. 
#'
#' @return Phylogenetic tree with unwanted samples removed. 
#'
#' @noRd
format_tree <- function(tree, sample_lookup){
  tree$tip.label <- gsub('_', "", tree$tip.label)
  ERIN_label <- vector(mode = "character", length(tree$tip.label))
  for (i in 1:length(tree$tip.label)) { 
    for (j in 1:nrow(sample_lookup)) {
      if (tree$tip.label[i] == sample_lookup$PSM_ID[j]) {
        ERIN_label[i] <- as.character(sample_lookup$ERIN_ID[j])
      }
    }
  }
  tree$tip.label <- ERIN_label
  tree <- drop.tip(tree, c(1:Ntip(tree))[!(tree$tip.label != "")])
  tree <- 
    drop.tip(tree, c(1:Ntip(tree))[tree$tip.label %in% sample_lookup$PSM_ID])
  return(tree)
} # end format_tree()

#' format_matrix
#' A function to drop unwanted samples from the matrix and convert PSM_ID into
#'   ERIN_ID. 
#'
#' @param matrix Matrix with isolates in the columns and variants in the rows. 
#' @param sample_lookup A key with 2 columns: PSM_ID, used for UMich sequencing 
#' core, and ERIN_ID, study ID numbers. 
#'
#' @return Matrix with unwanted samples removed and transposed.  
#'
#' @noRd
format_matrix <- function(matrix, lookup){
  colnames(matrix) <- gsub("_R1.*gz", "", colnames(matrix))
  colnames(matrix) <- gsub("_S.*$", "", colnames(matrix))
  colnames(matrix) <- gsub("_.*$", "", colnames(matrix))
  if (sum(row.names(matrix) %in% lookup$PSM_ID) < 1) {
    matrix <- t(matrix)
  }
  matrix <- matrix[row.names(matrix) %in% lookup$PSM_ID, , drop = FALSE]
  for (i in 1:nrow(matrix)) {
    for (j in 1:nrow(lookup)) {
      if (row.names(matrix)[i] == lookup$PSM_ID[j]) {
        row.names(matrix)[i] <- lookup$ERIN_ID[j]
      }
    }
  }
  return(matrix)
} # end format_matrix()

#' simplify_snp_code
#' This function converts a matrix with single nucleotide variants that are 
#'   encoded with various features (filtered, unmapped, phage, FQ, MQ) and
#'   creates an easier to interpret version: either the variant is present (1) 
#'   or it is absent (0). 
#'
#' @param snp_matrix Matrix. Matrix generated by Snitkin Lab variant calling 
#'   pipeline: https://github.com/alipirani88/variant_calling_pipeline. 
#' @param keepMQ Logical. Decide whether or not to include lowMQ positions. 
#'
#' @return simplified_code_snpmat Matrix. Entries are all binary: 0 or 1. 
#' 
#' @noRd
simplify_snp_code <- function(snp_matrix, keepMQ = FALSE){
  simplified_code_snpmat <- snp_matrix
  simplified_code_snpmat[simplified_code_snpmat == 3] <- 1 # true variant
  simplified_code_snpmat[simplified_code_snpmat == 2] <- 0 # filtered variant
  simplified_code_snpmat[simplified_code_snpmat == -1] <- 0 # unmapped
  simplified_code_snpmat[simplified_code_snpmat == -2] <- 0 # phage
  simplified_code_snpmat[simplified_code_snpmat == -3] <- 0 # lowFQ
  if (keepMQ) {
    simplified_code_snpmat[simplified_code_snpmat == -4] <- 1 # keep lowMQ
  } else {
    simplified_code_snpmat[simplified_code_snpmat == -4] <- 0 # remove lowMQ
  }

  if (sum(sum(simplified_code_snpmat == 1) + sum(simplified_code_snpmat == 0)) 
      != (ncol(simplified_code_snpmat) * nrow(simplified_code_snpmat))) {
    stop("snpmat encoded incorrectly.")
  }
  return(simplified_code_snpmat)
} # end simplify_snp_code()

#' save_data_for_tre_analysis
#' Given all of the input data, saves a tibble and a tree with all of the 
#'   relevant data and only the good samples. 
#' @param out_group Character. Name of the outgroup sample. 
#' @param keeper_path Characater. Path to a file with only the good samples. 
#'   Dim: 2 columns: PSM_ID (internal sequencing ID) & ERIN_ID (study ID)
#' @param tree_path Character. Path to phylogenetic tree. 
#' @param snp_path Character. Path to SNP matrix. Encoded in numbers not 
#'   alleles. 
#' @param pan_path Character. Path to pan genome matrix. 
#' @param model_path Character. Path to model information.
#'
#' @noRd  
save_data_for_tre_analysis <- function(out_group, 
                                       keeper_path,
                                       tree_path, 
                                       snp_path,
                                       pan_path,
                                       model_path){
  # Load in all relevant data -------------------------------------------------#
  # ID Key with only the high quality samples
  keepers <-
    read.table(keeper_path,
               header = TRUE,
               stringsAsFactors = FALSE,
               sep = ",",
               quote = "")
  
  # Phylogenetic tree
  tree <- read.tree(tree_path)
  
  # SNP matrix
  snp <- read.table(snp_path,
                    header = TRUE,
                    stringsAsFactors = FALSE,
                    sep = "\t",
                    quote = "",
                    row.names = 1)
  
  # Pan genome matrix
  pangenome <- read.csv(pan_path,
                        header = TRUE,
                        row.names = 1,
                        sep = "\t",
                        stringsAsFactors = FALSE)
  
  # Logistic model variables, risk score, ribotype, metadata, etc...
  model_data <- read_tsv(model_path,
                         col_names = TRUE)
  
  # Subset data to only high quality samples ----------------------------------#
  keepers <- rbind(keepers, c(out_group, out_group)) 
  
  # Root phylogenetic tree to the outgroup.
  tree <- root(tree, out_group)
  tree <- drop.tip(tree, out_group)
  tree <- format_tree(tree, keepers)
  
  # Remove outgroup from keepers now that tree is rooted
  keepers <- keepers[ -which(keepers[ , 1] == out_group), ]
  pangenome <- format_matrix(pangenome, keepers)
  
  # Subset SNPs to only trehalose relevant genes (TreR, CD630_30900)
  # Then subset to only desired isolates. 
  treR_snps <- snp[grep("locus_tag=CD630_30900 ", rownames(snp)), 
                   , 
                   drop = FALSE]
  treR_snps <- format_matrix(treR_snps, keepers)
  
  # Convert SNPs from code matrix form (which encodes information quality) into 
  #   a simple matrix with just presence/absence (1/0) ------------------------#
  treR_snps <- simplify_snp_code(treR_snps)
  
  # Generate data for specific trehalose utilization variant analyses ---------#
  colnames(treR_snps) <- 
    colnames(treR_snps) %>% 
    gsub("^.*p[.]", "", .) %>% 
    gsub("[|][0-9]+/723.*$", "", .)
  
  # Only keep variants causing amino acid changes (remove synonymous mutations)
  no_amino_acid_substitution <- 
    colnames(treR_snps)[(substr(colnames(treR_snps), 1, 3) == substr(colnames(treR_snps), nchar(colnames(treR_snps)) - 2, nchar(colnames(treR_snps)))) & nchar(colnames(treR_snps)) > 6]
  treR_snps <- 
    treR_snps[ , !(colnames(treR_snps) %in% no_amino_acid_substitution), drop = FALSE]
  
  # Four gene trehalose insertion from pan genome matrix
  four_gene_insertion <- 
    cbind(pangenome[, grep("treA_1",     colnames(pangenome))[1], drop = FALSE],
          pangenome[, grep("treB",       colnames(pangenome))[1], drop = FALSE], 
          pangenome[, grep("group_5209", colnames(pangenome))[1], drop = FALSE], 
          pangenome[, grep("treR_1",     colnames(pangenome))[1], drop = FALSE])
  four_gene_insertion <- 
    cbind(four_gene_insertion, rowSums(four_gene_insertion))
  colnames(four_gene_insertion) <- 
    c("treA2", "ptsT", "treX", "treR2", "four_gene_insertion")
  four_genes <- 4
  present <- 1
  absent <- 0
  four_gene_insertion <- as_tibble(four_gene_insertion, rownames = "ERIN_ID")
  
  four_gene_insertion$four_gene_insertion[
    four_gene_insertion$four_gene_insertion < four_genes] <- absent
  four_gene_insertion$four_gene_insertion[
    four_gene_insertion$four_gene_insertion == four_genes] <- present

  # Join all information together ---------------------------------------------#
  metadata <- keepers[match(tree$tip.label, keepers$ERIN_ID), , drop = FALSE] 
  if (!identical(metadata$ERIN_ID, tree$tip.label)) {
    stop("Metadata IDs should exactly match the order of the tree tips")
  }
  metadata <- as_tibble(metadata)
  
  treR_snps <- as_tibble(treR_snps, rownames = "ERIN_ID")
  metadata <- left_join(metadata, four_gene_insertion, by = "ERIN_ID")
  metadata <- left_join(metadata, treR_snps, by = "ERIN_ID")
  if (!identical(metadata$ERIN_ID, tree$tip.label)) {
    stop("Metadata IDs should exactly match the order of the tree tips")
  }
  metadata <- 
    metadata %>% 
    mutate("C171S_L172I_or_insertion" = 
             rowSums(select(., four_gene_insertion, Cys171Ser, Leu172Ile), 
                     na.rm = TRUE))
  has_some_variant <- 1
  metadata$C171S_L172I_or_insertion[
    metadata$C171S_L172I_or_insertion < has_some_variant] <- absent
  metadata$C171S_L172I_or_insertion[
    metadata$C171S_L172I_or_insertion >= has_some_variant] <-  present
  
  if (!identical(metadata$ERIN_ID, tree$tip.label)) {
    stop("Metadata IDs should exactly match the order of the tree tips")
  }
  
  metadata <- full_join(metadata, model_data, by = "ERIN_ID")
  metadata <- metadata %>% mutate("WGS_performed" = as.logical(!is.na(PSM_ID)))
  
  colnames(metadata)[which(colnames(metadata) == "ERIN_ID")] <- "ID"
  
  metadata <- metadata %>% select(-PSM_ID)
  # Save tree  
  write.tree(tree, 
             file = paste0("../data/outputs/", Sys.Date(), "_trehalose.tree"))
  
  # Save metadata
  write.table(metadata, 
              file = paste0("../data/outputs/", 
                            Sys.Date(), 
                            "_pre-analysis_trehalose_metadata.tsv"), 
              sep = "\t", 
              quote = FALSE, 
              col.names = TRUE, 
              row.names = FALSE)
  
  # Save metadata for Supplementary table 1
  metadata <- 
    metadata %>% 
    select(-age, 
           -gender..M.0.F.1.,
           -METS, 
           -concurrentabx, 
           -Lowest_SBP, 
           -highcreat,
           -highbili,
           -WBC,
           -Duplicated_Patient,
           -Missing_Model_Data,
           -Duplicated_Patient_No_Missing_Info)
  
  write.table(metadata, 
              file = paste0("../data/outputs/", 
                            Sys.Date(), 
                            "_trehalose_metadata_for_supplement.tsv"), 
              sep = "\t", 
              quote = FALSE, 
              col.names = TRUE, 
              row.names = FALSE)
} # end save_data_for_tre_analysis()